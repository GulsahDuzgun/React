### What did I learn while coding this project?

> #
>
> - _Components describe a piece of the user interface. The Component is a regular Javascript function which returns React elements -usually written as JSX-. A component is a generic description of the UI. We can think of a component as a blueprint or a template. ,_
> - _Component Instances are created when we use components. Component instance is like the actual physical manifestation of a component living. Each instance has its own lifecycle, state and props. Component instance returns one or more React elements. The JSX code in React Component gets converted to multiple React.createElement() function calls. React element is result of using a component in our code. It is a big immutable Javascript object that React keeps in memory. React element keeps information necessary to create DOM elements. React elements eventually are converted to DOM elements. DOM elements visual representation of the React Element on the browser ,_
> - _**How components are displayed on the screen?** First render is triggered, then in render phase React calls component functions and figures out how DOM should be updated. Then in Commit Phase React actually writes to the DOM, updating, inserting and deleting elements. Then Browser Paint. ,_
> - _In React, rendering is not updating DOM or displaying elements on the screen. Rendering only happend internally inside React. It does not produce visual changes. ,_
> - _**How Renders are triggered?** In two situations that trigger renders. 1- Initial render of the application, 2- State is updated in one or more component instance(re-render) _
> - _The render process is triggered for the entire application. In practice it looks like React only re-renders the component where the state update happend but that's not how it works behind the scenes. Renders are not triggered immediately, but scheduled for when the JS engine has some "free time ". There is also batching of multiple setState calls in the event handlers. ,_
> - _**The Render Phase** At the beginning of the render phase React will go through the entire component tree. Take all the component instances that triggered a re-render and actually render them. This will create updated React elements which altogether make up the so-called virtual DOM. ,_
> - _**What is the Virtual DOM(React Element Tree)?** In the initial render react will take the entire component tree and transform it into one big React element which calls Virtual DOM. Virtual DOM is just a tree of all React elements created from all instances in the component tree. It is cheap and fast to create multiple trees in the end it is just a Javascript Object.,_
> - _Whenever React renders a component, that render causes all of its child components to be rendered as well, no matter if props changed or not because React doesn't know whether children will be affected ,_
> - _We don't update the entire DOM whenever state changes somewhere in the app? Because that would be inefficient and wasteful. Writing to the DOM is slow and expensive. Also usually small part of the DOM needs to be updated. ,_
> - _**What is reconciliation and why do we need it?** Reconciliation is deciding which DOM elements actually need to be inserted, deleted or updated in order to reflect the lastest state changes. Result of the reconciliation process is gonne be a list of DOM operations that are necessary to update the current DOM with a new state. Reconciliation is processed by a reconciler. Reconciler allows us to never touch the DOM directly and instead simply tell React what the next snapshot of the UI should look like based on state. Current reconciler in React is called Fiber. ,_
> - _The Reconciler:**FIBER**: During the initial render of the application Fiber takes the entire React element tree so the Virtual DOM and based on it builds another tree which is the Fiber tree.Fiber tree is a special internal tree where for each component instance and DOM element in the app is called Fiber.,_
> - _The special about Fiber tree is unlike React elements in the Virtual DOM, Fiber are not created on every render. So the Fiber tree is never destroyed. Instead, it's a mutable data structure and once it has been created during the initial render it is simply mutated over and over again in future reconciliation steps. And this makes Fibers the perfect place for keeping track of things like current state, props, side effects, used hooks, queue of work to do like updating state, updating refs, running registered side effects, performing DOM updates , etc. This is also why fiber is defined as unit of work. ,_
> - _In Fiber tree, the Fibers are arranged in a different way than the elements in the React element tree. Instead of parent-child relationship each first child has a link to its parent and all the other children then have a link to their previous sibling. This kind of structure is called a linked list and it makes it easier for React to process the work that is associated with each Fiber.,_
> - _The one extremely important characteristic of the Fiber reconciler is that work can be performed asynchronously. This means that the rendering process which is what the reconciler does can be split into chunks, sone tasks can be prioritized over others and work can be paused, reused or thrown away if not valid anymore.In render phase is not created any virtual DOM.,_
> - _The process of comparing elements in current fiber tree and updated fiber tree step-by-step based on their position in the tree is called diffing.Once this process is over all these DOM mutations will be placed into a list called list of effects. The final result of render phase is list of effects ,_
>
> #
