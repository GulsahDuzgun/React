### What did I learn while coding this project?

> #
>
> - _**What is Context API?** Context API prevents prop drilling and allows components everywhere in the tree to read state that a context shares. Context API is a system to pass data throughout the application without having to manually pass props down the component tree. It essentially allows us to broadcast global state. ,_
> - _The first part of the Context API is the provider which is a special React component that gives all child components access to a so-called value. This provider can sit everywhere in the component tree but it's common to place it at the very top. And pass this state value into the provider. And Consumers all components that read the provided context value. Consumers are the components that subscribe to the context so they are able to read the value from the context. We can create as many consumer as we want. ,_
> - _When the state value gets updated all consumers will be re-rendered. All the components that are reading the context value. Whenever the value is updated the provider will immediately notify the consumers about the value change and it will re-render those components. ,_
> - _A component instance gets re-rendered only in 3 different situations: State Changes, Context Changes, Parent Re-renders(prop updates) ,_
> - _**What is memoization?** Memoization is an optimization technique that executes a pure function one time then it stores the results in cache. If we later try to execute the same function again with the same inputs, it will simply return the results that was previously stored in the cache. If the arguments are exactly the same as before it means that in a pure function, the output will be the same. On the other hand inputs are different, the function will be executed again ,_
> - _**What is memoization in React?** We can memoize components with memo, memoize objects with useMemo, memoize functions with useCallback. With doing memoize we prevent wasted renders and improve app speed/responsiveness. _
> - _React contains a memo function. We can use this function to create a component that will not re-render when its parent re-renders as long as the past prop stay the same between renders. We use memo to create a memoized component. The regular behaviour in React whenever the components re-renders the child components are re-rendered as well. If we memoize the child component, it will not re-render as lons as the props are the same as in the previous render. If the props do cahange then the child component will need to re-render in order to reflect this new data that it was received. ,_
> - _A memoized component will still re-render when its own state changes or a context that it is subscribed to. ,_
> - _memo is useful when we dealing with heavy component, re-renders quite frequently and does so with the same props. ,_
> - _Whenever a component instance re-renders everything in there is re-created that includes objects and functions that are defined within the component. So a new render gets new functions and new objects even if they are the exact same ones as before. In javascript two objects or functions are different ({} !== {}). If we pass an object or function to a child componet as a prop, that child component will always see them as a new props whenever there is a re-render. If props are different between re-renders then memo simply will not work. If we memorize a component but then give it objects or functions as props, the component will always re-render anyway because it will always see these props as new props even they actually look exactly the same. We can preserve them between renders by memoizing them and make them stable. To that, React gives us two more hooks: useMemo and useCallback. ,_

> - _We use useMemo() to any value preserve them between renders and useCallback to memoize functions between renders. Whatever value is passed to useMemo() or useCallback() will be stored in memory. That cached value then be returned in future re-renders. It will be preserved across renders as long as the inputs stay the same. These inputs are called dependencies. Like useEffect() hook useMemo() and useCallback() also have a dependency array. Whenever one of the dependencies changes, the value will no longer be returned from the cache instead be recreated. ,_
> - _Regular behavior in React when we do not memorize a certain value is that new value is created whenever the component re-renders. On the other hand, when we do memorize the value then no new value is created on re-render and the cached value is returned insted. If the dependency array has changed then the new value is created as if the memorization has never happened. ,_
> - _**When do we need to use useMemo() and useCallback()?** Memoizing props to prevent wasted renders, memoizing values to avoid expensive re-calculation on every render, memoizing values that are used in dependency array of another hook(in order to avoid infinite useEffect loops). ,_
>
> #
